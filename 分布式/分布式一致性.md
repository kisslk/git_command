# 分布式一致性

## 1、酸碱平衡理论

### ACID(酸)

- 原子性
- 一致性
- 隔离型
- 持久性

### CAP(帽子理论)

- 一致性
- 可用性
- 分区容忍性

### BASE(碱)

- BA，基本可用
- Soft State，软状态，状态可以一定时间内不重复
- Eventually Consistent，最终一致性

## 2、分布式协议的一致性

### JEE规范

- TX：定义应用程序与事务管理器之间的接口
- XA：定义事务管理器和资源管理器之间的接口

### 二阶段提交

- 过程

	- 准备阶段
	- 提交阶段

- 弊端

	- 阻塞，是重量级操作，会锁定资源
	- 单点故障

		- 协调者宕机，参与者会一只阻塞不可用
		- 协调者发送一个提交指令后宕机，如果只有一个参与者接口到指令，并且参与者接收后也宕机，则新上任的协调者无法处理这种情况

	- 脑裂，有的参与者接收并处理的事务，但是有的参与者没有接收到事务，这样多个参与者之间是不一致的

### 三阶段提交

- 过程

	- 询问阶段
	- 准备阶段
	- 提交阶段

- 弊端

	- 一旦发生超时，数据仍然会不一致

- 优势

	- 增加了询问阶段，确保无法执行的操作不被执行，但是并不能发现所有这种行为，只会减少这种情况的发生
	- 在准备阶段以后，协调者和参与者都增加了超时，一旦超时，则协调者和参与者都会继续提交事务，默认为成功
	- 不会阻塞和永远锁定资源

## 3、保证最终一致性的模式

### 查询模式

- 主键或业务ID查询

	- 全局唯一ID：例如snowflak

- 分页条件查询

### 补偿模式

- 自动恢复：重试或者回滚
- 通知运营：如手动调整库存
- 技术运营：数据或代码变更

### 异步确保模式

- CompleteFuture
- Spring Reactive

### 定期校对模式

- 调用连跟踪系统：Dapper

	- pinpoint
	- skywalking
	- zipkin
	- sluth

### 可靠消息模式

- 消息的可靠发送

	- 发送之前将消息持久化到数据库，然后定时任务捞取一定时间内未发送的消息
	- 第三方消息管理器

- 消息处理器的幂等性

	- 使用主键滤重
	- 使用分布式表对请求进行滤重
	- 使用状态流转的方向性滤重，通常使用数据库的行级锁来实现
	- 根据业务特点：比如查询/新增/删除某个资源

- 消息的可靠消费

	- 消息管理器发送消息给处理机，处理机持久化该消息，消息管理器把消息删除。处理机消费失败，从处理机的数据库捞取进行重试

### 缓存一致性模式

- 如果对性能要求不是特别高，尽量使用分布式缓存，而不是本地缓存
- 写缓存数据一定要完整
- 缓存与数据库之间保持弱一致性
- 先读缓存再读数据库。先写数据库，后写缓存

## 4、微服务的交互模式

### 同步调用模式

### 接口异步调用模式

### 消息队列异步处理模式

## 5、同步与异步的抉择

### 尽量使用异步来替换同步操作

### 能用同步解决的问题，不要引入异步

## 6、交互模式下超时问题的解决方案

### 同步调用模式下的解决方案

- 两状态的同步接口

	- 超时后使用查询模式查询状态，进行重试处理
	- 消费者内部二次调用失败，就快速失败，查询状态并进行冲正操作

- 三状态的同步接口（处理中）

	- 失败后看作处理中的一个特例
	- 消费者内部二次调用失败，进行重试补偿

### 异步调用模式下的解决方案

- 异步调用接口超时

	- 通过查询来补齐状态

- 异步调用内部超时

	- 通过查询补齐后续状态

- 异步调用回调超时

	- 重试补偿

		- spring retry

### 消息队列异步处理模式的解决方案

- 消息队列的生产者超时

	- 见3、可靠消息模式

- 消息队列的消费者超时

	- 见3、可靠消息模式

## 7、超时补偿的原则

### 消费者接收消息，先持久化再响应接收成功，随后消费者才处理消息

### 生产者调用消费者，如果消费者没有给明确的接收响应，那么应该进行重试

## 8、迁移开关的设计

### 基于应用

### 基于配置系统

### 基于实体

- 推荐

*XMind: ZEN - Trial Version*
